/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 .\\public\\Goldfish.glb
*/

import React, { useEffect, useRef, useState } from "react";
import { useGLTF } from "@react-three/drei";
import * as THREE from "three";
import { useFrame } from "@react-three/fiber";
import { Vector3 } from "three";
import node from "three/addons/nodes/core/Node.js";
import { Stonefish } from "./Stonefish";

let meshes = [];
const originalPositions = {};

export function GoldFish(props) {
  const { nodes, materials } = useGLTF("/Goldfish.glb");

  console.log(materials);
  console.log(nodes);
  Object.keys(materials).forEach((mKey) => (materials[mKey].side = THREE.DoubleSide));

  const animateSwim = (geo, index, elapsedTime) => {
    if (!originalPositions[index]) return;

    const positionArray = originalPositions[index];

    for (let i = 0; i < positionArray.length; i += 3) {
      const xPos = positionArray[i];
      const yPos = positionArray[i + 1];
      const zPos = positionArray[i + 2];

      let pos = new Vector3(xPos, yPos, zPos);
      pos.x = xPos + Math.sin(elapsedTime * 6 + Math.sin(zPos) * 5) / 20;
      geo.attributes.position.array[i] = pos.x;
      geo.attributes.position.array[i + 1] = pos.y;
      geo.attributes.position.array[i + 2] = pos.z;
    }

    geo.attributes.position.needsUpdate = true;

    return geo;
  };

  if (!meshes || meshes.length === 0) {
    meshes = Object.keys(nodes)
      .filter((nodeKey) => nodes[nodeKey].type === "Mesh")
      .map((nodeKey, index) => {
        let geo = nodes[nodeKey].geometry;

        originalPositions[index] = [];

        for (let i = 0; i < geo.attributes.position.array.length; i += 3) {
          const xPos = geo.attributes.position.array[i];
          const yPos = geo.attributes.position.array[i + 1];
          const zPos = geo.attributes.position.array[i + 2];

          originalPositions[index][i] = xPos;
          originalPositions[index][i + 1] = yPos;
          originalPositions[index][i + 2] = zPos;
        }

        return geo;
      });
  }

  useFrame(({ clock }) => {
    const elapsedTime = clock.getElapsedTime();

    meshes = meshes.map((geo, index) => animateSwim(geo, index, elapsedTime));
  });

  return (
    <group {...props} dispose={null}>
      <instancedMesh castShadow receiveShadow ref={props.fishRef[0]} args={[null, null, props.amount ?? 1]} geometry={meshes[0]} material={materials["Material.003"]} />
      <instancedMesh castShadow receiveShadow ref={props.fishRef[1]} args={[null, null, props.amount ?? 1]} geometry={meshes[1]} material={materials["Material.002"]} />
      <instancedMesh castShadow receiveShadow ref={props.fishRef[2]} args={[null, null, props.amount ?? 1]} geometry={meshes[2]} material={materials["Material.001"]} />
      <instancedMesh castShadow receiveShadow ref={props.fishRef[3]} args={[null, null, props.amount ?? 1]} geometry={meshes[3]} material={materials["Material.004"]} />
      <instancedMesh castShadow receiveShadow ref={props.fishRef[4]} args={[null, null, props.amount ?? 1]} geometry={meshes[4]} material={materials.Material} />
    </group>
  );
}

useGLTF.preload("/Goldfish.glb");
